<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>贪吃蛇游戏</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" />

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#FF3A3A',
            secondary: '#00A8FF',
            accent: '#FFD166',
            dark: '#1A1A2E',
            'dark-light': '#16213E',
          },
        },
      },
    };
  </script>
</head>
<body class="bg-dark text-white font-sans min-h-screen">
  <!-- 导航栏 -->
  <nav class="bg-dark-light fixed w-full py-3 px-4">
    <div class="flex justify-between items-center">
      <h1 class="text-xl font-bold text-primary">贪吃蛇游戏</h1>
      <a href="#" id="homeBtn" class="text-gray-300 hover:text-white">
        <i class="fa fa-home mr-1"></i>主页
      </a>
    </div>
  </nav>

  <!-- 主内容区 -->
  <main class="pt-16 pb-8 px-4 max-w-4xl mx-auto">
    <div class="flex flex-col lg:flex-row gap-4">
      <!-- 游戏区域 -->
      <div class="lg:w-2/3 bg-dark-light rounded-md p-4 min-w-[620px]">
        <div class="text-center mb-4">
          <h2 class="text-xl font-bold text-accent">游戏区域</h2>
        </div>

        <!-- 游戏画布 -->
        <div class="bg-black rounded-md overflow-hidden" style="height: 600px; width: 600px;">
          <canvas id="gameCanvas" width="600" height="600"></canvas>
        </div>

        <!-- 游戏控制 -->
        <div class="mt-4 flex justify-center gap-4">
          <button id="startBtn" class="bg-primary hover:bg-primary/80 text-white px-4 py-2 rounded-md">
            <i class="fa fa-play mr-1"></i>开始游戏
          </button>
          <button id="pauseBtn" class="bg-secondary hover:bg-secondary/80 text-white px-4 py-2 rounded-md" disabled>
            <i class="fa fa-pause mr-1"></i>暂停
          </button>
          <button id="restartBtn" class="bg-accent hover:bg-accent/80 text-white px-4 py-2 rounded-md" disabled>
            <i class="fa fa-refresh mr-1"></i>重新开始
          </button>
        </div>
      </div>

      <!-- 游戏信息 -->
      <div class="lg:w-1/3 bg-dark-light rounded-md p-4">
        <div class="text-center mb-4">
          <h2 class="text-xl font-bold text-secondary">游戏信息</h2>
        </div>

        <div class="space-y-4">
          <div class="bg-dark rounded-md p-3">
            <div class="flex justify-between items-center">
              <span class="text-gray-400">当前分数</span>
              <span id="score" class="text-xl font-bold text-primary">0</span>
            </div>
          </div>

          <div class="bg-dark rounded-md p-3">
            <div class="flex justify-between items-center">
              <span class="text-gray-400">移动步数</span>
              <span id="moves" class="text-xl font-bold text-secondary">0</span>
            </div>
          </div>

          <div class="bg-dark rounded-md p-3">
            <div class="flex justify-between items-center">
              <span class="text-gray-400">游戏时间</span>
              <span id="time" class="text-xl font-bold text-accent">00:00</span>
            </div>
          </div>

          <div class="bg-dark rounded-md p-3">
            <h3 class="font-bold mb-2">操作说明</h3>
            <ul class="text-sm text-gray-300 space-y-1">
              <li><i class="fa fa-arrow-up mr-1"></i>上移</li>
              <li><i class="fa fa-arrow-down mr-1"></i>下移</li>
              <li><i class="fa fa-arrow-left mr-1"></i>左移</li>
              <li><i class="fa fa-arrow-right mr-1"></i>右移</li>
              <li><i class="fa fa-space-shuttle mr-1"></i>空格键: 暂停/继续</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // 检查用户是否登录
    async function checkLogin() {
      try {
        const response = await fetch('http://127.0.0.1:5000/api/check_login', {
          credentials: 'include',
        });
        const data = await response.json();
        return data.message === '已登录';
      } catch (error) {
        console.error('检查登录状态失败:', error);
        return false;
      }
    }

    // 页面加载时检查登录状态
    checkLogin().then(isLoggedIn => {
      if (!isLoggedIn) {
        window.location.href = 'login.html';
      }
    });

    // 游戏逻辑实现
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreElement = document.getElementById('score');
      const movesElement = document.getElementById('moves');
      const timeElement = document.getElementById('time');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');

      // 设置画布尺寸
      canvas.width = 600;
      canvas.height = 600;

      // 游戏变量
      let snake = [{ x: 10, y: 10 }];
      let food = { x: 5, y: 5 };
      let direction = 'right';
      let nextDirection = 'right';
      let score = 0;
      let moves = 0;
      let gameTime = 0;
      let gameInterval;
      let isPaused = false;
      let gameStarted = false;
      let timerInterval;
      let isGameOver = false; // 标记游戏是否结束
      let isRestarting = false; // 修复：修正拼写错误（isResarting → isRestarting）

      // 游戏网格大小
      const gridSize = 20;

      // 初始化游戏
      function initGame() {
        snake = [{ x: 10, y: 10 }];
        food = { x: 5, y: 5 };
        direction = 'right';
        nextDirection = 'right';
        score = 0;
        moves = 0;
        gameTime = 0;
        isPaused = false;
        isGameOver = false;

        updateDisplay();
        generateFood();
        draw();
      }

      // 开始游戏
      function startGame() {
        if (gameStarted) return;

        gameStarted = true;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        restartBtn.disabled = false;
        isPaused = false;
        isGameOver = false;

        gameInterval = setInterval(gameLoop, 100);
        timerInterval = setInterval(() => {
          gameTime++;
          updateDisplay();
        }, 1000);
      }

      // 暂停游戏
      function pauseGame() {
    if (isRestarting) return;  // 新增：重新开始流程中忽略暂停操作

    isPaused = !isPaused;

    if (isPaused) {
        // 暂停时彻底清除定时器
        if (gameInterval) {
            clearInterval(gameInterval);
            gameInterval = null;  // 显式设为null，避免残留引用
        }
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        pauseBtn.innerHTML = '<i class="fa fa-play mr-1"></i>继续';
    } else {
        // 恢复时重新创建唯一定时器
        gameInterval = setInterval(gameLoop, 100);  // 保持原间隔
        timerInterval = setInterval(() => {
            gameTime++;
            updateDisplay();
        }, 1000);
        pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';
    }
}

      // 重新开始游戏
      // 修复：注释符号错误（/ → //）
      // 完全重构restartGame函数
      function restartGame() {
    if (isRestarting) return;
    isRestarting = true;

    // 重新开始时立即禁用暂停按钮
    pauseBtn.disabled = true;  // 新增：禁用暂停按钮
    restartBtn.disabled = true;

    // 清除所有现有定时器（关键步骤）
    if (gameInterval) {
        clearInterval(gameInterval);
        gameInterval = null;
    }
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }

          // 显示确认对话框
          const confirmRestart = confirm(isGameOver
              ? '游戏已经结束，是否重新开始？'
              : '是否确认重新开始？');

          if (confirmRestart) {
              // 保存当前记录（如果游戏已开始）
              if (gameStarted) {
                  saveGameRecord(
                      score,
                      moves,
                      `${Math.floor(gameTime / 60)
                          .toString()
                          .padStart(2, '0')}:${(gameTime % 60).toString().padStart(2, '0')}`
                  );
              }

              // 初始化游戏状态
              initGame();
              draw();

              // 倒计时后启动游戏
              let count = 3;
              const countdownInterval = setInterval(() => {
                  draw(); // 绘制游戏状态

                  // 绘制倒计时
                  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                  ctx.fillRect(0, 0, canvas.width, 80);
                  ctx.fillStyle = '#FFD166';
                  ctx.font = 'bold 48px Arial';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillText(count > 0 ? `准备开始: ${count}` : '开始！', canvas.width / 2, 40);

                  count--;

                  if (count < -1) {
                      clearInterval(countdownInterval);
                      draw(); // 清除倒计时显示

                      // 启动游戏
                      gameStarted = true;
                      isPaused = false;
                      isGameOver = false;
                      startBtn.disabled = true;
                      pauseBtn.disabled = false;
                      pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';

                      // 启动游戏循环
                      gameInterval = setInterval(gameLoop, 100);
                      timerInterval = setInterval(() => {
                          gameTime++;
                          updateDisplay();
                      }, 1000);

                      // 重置状态，启用按钮
                      isRestarting = false;
                      restartBtn.disabled = false;
                      pauseBtn.disabled = false;
                  }
              }, 1000);
          } else {
              // 用户取消重新开始
              if (isGameOver) {
                  // 游戏已结束时取消，保持结束状态
                  startBtn.disabled = false;
              } else if (gameStarted) {
                  // 游戏进行中取消，恢复游戏
                  isPaused = false;
                  gameInterval = setInterval(gameLoop, 100);
                  timerInterval = setInterval(() => {
                      gameTime++;
                      updateDisplay();
                  }, 1000);
                  pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';
              }

              // 重置状态，启用按钮
              isRestarting = false;
              restartBtn.disabled = false;
          }
      }

      // 游戏主循环
      function gameLoop() {
        if (isPaused || isGameOver) return;

        // 更新蛇的位置
        const head = { x: snake[0].x, y: snake[0].y };

        switch (direction) {
          case 'up':
            head.y--;
            break;
          case 'down':
            head.y++;
            break;
          case 'left':
            head.x--;
            break;
          case 'right':
            head.x++;
            break;
        }

        // 检查是否碰撞边界
        if (
          head.x < 0 ||
          head.x >= canvas.width / gridSize ||
          head.y < 0 ||
          head.y >= canvas.height / gridSize
        ) {
          gameOver();
          return;
        }

        // 检查是否碰撞自身
        for (let i = 0; i < snake.length; i++) {
          if (snake[i].x === head.x && snake[i].y === head.y) {
            gameOver();
            return;
          }
        }

        // 更新方向
        direction = nextDirection;
        moves++;

        // 将新头部添加到蛇身体
        snake.unshift(head);

        // 检查是否吃到食物
        if (head.x === food.x && head.y === food.y) {
          score += 10;
          generateFood();
        } else {
          // 如果没吃到食物，移除尾部
          snake.pop();
        }

        // 更新显示
        updateDisplay();
        draw();
      }

      // 生成食物
      function generateFood() {
        let newFood;
        do {
          newFood = {
            x: Math.floor(Math.random() * (canvas.width / gridSize)),
            y: Math.floor(Math.random() * (canvas.height / gridSize)),
          };
        } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));

        food = newFood;
      }

      // 绘制游戏
      function draw() {
          // 清空画布
          ctx.fillStyle = 'black';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // 绘制网格
          ctx.strokeStyle = '#333';
          for (let x = 0; x < canvas.width; x += gridSize) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, canvas.height);
              ctx.stroke();
          }
          for (let y = 0; y < canvas.height; y += gridSize) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(canvas.width, y);
              ctx.stroke();
          }

          // 绘制蛇 - 优化版本
          snake.forEach((segment, index) => {
              const x = segment.x * gridSize;
              const y = segment.y * gridSize;

              // 创建渐变色
              const gradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize);

              // 根据蛇的位置设置不同颜色
              if (index === 0) {
                  // 头部 - 使用主色调渐变
                  gradient.addColorStop(0, '#FF6B6B');
                  gradient.addColorStop(1, '#FF3A3A');

                  // 绘制头部（带圆角）
                  ctx.fillStyle = gradient;
                  ctx.beginPath();
                  ctx.roundRect(x, y, gridSize - 1, gridSize - 1, 5);
                  ctx.fill();

                  // 绘制眼睛
                  ctx.fillStyle = 'white';
                  const eyeSize = gridSize / 6;
                  const eyeOffset = gridSize / 4;

                  // 根据方向调整眼睛位置
                  if (direction === 'right') {
                      ctx.beginPath();
                      ctx.arc(x + gridSize - eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.arc(x + gridSize - eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.fill();
                  } else if (direction === 'left') {
                      ctx.beginPath();
                      ctx.arc(x + eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.arc(x + eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.fill();
                  } else if (direction === 'up') {
                      ctx.beginPath();
                      ctx.arc(x + eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.arc(x + gridSize - eyeOffset, y + eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.fill();
                  } else if (direction === 'down') {
                      ctx.beginPath();
                      ctx.arc(x + eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.arc(x + gridSize - eyeOffset, y + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
                      ctx.fill();
                  }

                  // 绘制瞳孔
                  ctx.fillStyle = 'black';
                  const pupilSize = eyeSize / 2;

                  if (direction === 'right') {
                      ctx.beginPath();
                      ctx.arc(x + gridSize - eyeOffset + 1, y + eyeOffset, pupilSize, 0, Math.PI * 2);
                      ctx.arc(x + gridSize - eyeOffset + 1, y + gridSize - eyeOffset, pupilSize, 0, Math.PI * 2);
                      ctx.fill();
                  } else if (direction === 'left') {
                      ctx.beginPath();
                      ctx.arc(x + eyeOffset - 1, y + eyeOffset, pupilSize, 0, Math.PI * 2);
                      ctx.arc(x + eyeOffset - 1, y + gridSize - eyeOffset, pupilSize, 0, Math.PI * 2);
                      ctx.fill();
                  } else if (direction === 'up') {
                      ctx.beginPath();
                      ctx.arc(x + eyeOffset, y + eyeOffset - 1, pupilSize, 0, Math.PI * 2);
                      ctx.arc(x + gridSize - eyeOffset, y + eyeOffset - 1, pupilSize, 0, Math.PI * 2);
                      ctx.fill();
                  } else if (direction === 'down') {
                      ctx.beginPath();
                      ctx.arc(x + eyeOffset, y + gridSize - eyeOffset + 1, pupilSize, 0, Math.PI * 2);
                      ctx.arc(x + gridSize - eyeOffset, y + gridSize - eyeOffset + 1, pupilSize, 0, Math.PI * 2);
                      ctx.fill();
                  }
              } else {
                  // 身体 - 使用次要色调渐变
                  // 根据位置变化颜色深浅
                  const colorIntensity = 1 - (index / snake.length) * 0.5;
                  gradient.addColorStop(0, `rgba(0, 168, 255, ${colorIntensity})`);
                  gradient.addColorStop(1, `rgba(0, 120, 255, ${colorIntensity})`);

                  // 身体部分带圆角，比头部小一点
                  ctx.fillStyle = gradient;
                  ctx.beginPath();
                  ctx.roundRect(x + 1, y + 1, gridSize - 3, gridSize - 3, 3);
                  ctx.fill();
              }
          });

          // 绘制食物（优化为圆形）
          ctx.fillStyle = '#FFD166';
          ctx.beginPath();
          ctx.arc(
              food.x * gridSize + gridSize / 2,
              food.y * gridSize + gridSize / 2,
              (gridSize - 1) / 2,
              0,
              Math.PI * 2
          );
          ctx.fill();

          // 食物高光效果
          ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.beginPath();
          ctx.arc(
              food.x * gridSize + gridSize / 3,
              food.y * gridSize + gridSize / 3,
              (gridSize - 1) / 6,
              0,
              Math.PI * 2
          );
          ctx.fill();

          // 如果游戏暂停，显示暂停信息
          if (isPaused) {
              ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.fillStyle = 'white';
              ctx.font = '20px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('游戏暂停', canvas.width / 2, canvas.height / 2);
          }
      }

      // 更新显示信息
      function updateDisplay() {
        scoreElement.textContent = score;
        movesElement.textContent = moves;

        const minutes = Math.floor(gameTime / 60)
          .toString()
          .padStart(2, '0');
        const seconds = (gameTime % 60).toString().padStart(2, '0');
        timeElement.textContent = `${minutes}:${seconds}`;
      }

      // 游戏结束
      function gameOver() {
    clearInterval(gameInterval);
    clearInterval(timerInterval);

    isGameOver = true;
    gameStarted = false;

    // 先绘制最后游戏状态
    draw();

    // 顶部显示游戏结束信息，不遮挡完整棋盘
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, 100);

    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('游戏结束', canvas.width / 2, 30);
    ctx.font = '20px Arial';
    ctx.fillText(`最终得分: ${score}`, canvas.width / 2, 70);

    // 保存游戏记录
    saveGameRecord(
        score,
        moves,
        `${Math.floor(gameTime / 60)
            .toString()
            .padStart(2, '0')}:${(gameTime % 60).toString().padStart(2, '0')}`
    );

    // 重置按钮状态
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    restartBtn.disabled = false;
    pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';
}


      // 保存游戏记录
      async function saveGameRecord(score, moves, time) {
        try {
          const response = await fetch('/api/game', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ score, moves, time }),
          });

          const data = await response.json();
          console.log(data.message);
        } catch (error) {
          console.error('Error saving game record:', error);
        }
      }

      // 键盘控制
      document.addEventListener('keydown', e => {
        if (!gameStarted) return;

        if (e.key === ' ') {
          pauseGame();
          return;
        }

        if (isPaused) return;

        switch (e.key) {
          case 'ArrowUp':
            if (direction !== 'down') nextDirection = 'up';
            break;
          case 'ArrowDown':
            if (direction !== 'up') nextDirection = 'down';
            break;
          case 'ArrowLeft':
            if (direction !== 'right') nextDirection = 'left';
            break;
          case 'ArrowRight':
            if (direction !== 'left') nextDirection = 'right';
            break;
        }
      });

      // 主页按钮点击事件
      document.getElementById('homeBtn').addEventListener('click', e => {
        e.preventDefault();
        if (gameStarted) {
          clearInterval(gameInterval);
          clearInterval(timerInterval);
          saveGameRecord(
            score,
            moves,
            `${Math.floor(gameTime / 60)
              .toString()
              .padStart(2, '0')}:${(gameTime % 60).toString().padStart(2, '0')}`
          ).then(() => {
            window.location.href = 'index.html';
          });
        } else {
          window.location.href = 'index.html';
        }
      });

      // 倒计时函数
      function countdownBeforeStart(callback) {
    let count = 3;

    const countdownInterval = setInterval(() => {
        draw();

        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, canvas.width, 80);
        ctx.fillStyle = '#FFD166';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(count > 0 ? `准备开始: ${count}` : '开始！', canvas.width / 2, 40);

        count--;

        if (count < -1) {
            clearInterval(countdownInterval);
            draw();
            callback();
        }
    }, 1000);
}


      // 按钮事件绑定
      startBtn.addEventListener('click', startGame);
      pauseBtn.addEventListener('click', pauseGame);
      restartBtn.addEventListener('click', restartGame);

      // 初始化游戏
      initGame();
    });
  </script>
</body>
</html>