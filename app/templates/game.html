<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>贪吃蛇游戏</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" />

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#FF3A3A',
            secondary: '#00A8FF',
            accent: '#FFD166',
            dark: '#1A1A2E',
            'dark-light': '#16213E',
          },
        },
      },
    };
  </script>
</head>
<body class="bg-dark text-white font-sans min-h-screen">
  <!-- 导航栏 -->
  <nav class="bg-dark-light fixed w-full py-3 px-4">
    <div class="flex justify-between items-center">
      <h1 class="text-xl font-bold text-primary">贪吃蛇游戏</h1>
      <a href="#" id="homeBtn" class="text-gray-300 hover:text-white">
        <i class="fa fa-home mr-1"></i>主页
      </a>
    </div>
  </nav>

  <!-- 主内容区 -->
  <main class="pt-16 pb-8 px-4 max-w-4xl mx-auto">
    <div class="flex flex-col lg:flex-row gap-4">
      <div class="lg:w-1/5 bg-dark-light rounded-md p-4 min-w-[200px]">
    <div class="text-center mb-2">
      <h2 class="text-lg font-bold text-yellow-400">公告栏</h2>
    </div>
    <div class="text-sm text-gray-300 space-y-2">
      <p><i class="fa fa-exclamation-circle mr-1 text-yellow-500"></i>难度只能选择一次。</p>
      <p><i class="fa fa-refresh mr-1 text-yellow-500"></i>如需更改难度，请返回主页重新进入游戏。</p>
    </div>
      </div>

      <!-- 游戏区域 -->
      <div class="lg:w-2/3 bg-dark-light rounded-md p-4 min-w-[620px]">
        <div class="text-center mb-4">
          <h2 class="text-xl font-bold text-accent">游戏区域</h2>
        </div>

        <!-- 游戏画布 -->
        <div class="bg-black rounded-md overflow-hidden" style="height: 600px; width: 600px;">
          <canvas id="gameCanvas" width="600" height="600"></canvas>
        </div>

        <!-- 难度选择 -->
        <div id="difficultySelection" class="mt-4 flex justify-center gap-4">
          <button data-difficulty="easy" class="difficulty-btn bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md transition-all duration-300">
            <i class="fa fa-smile-o mr-1"></i>简单
          </button>
          <button data-difficulty="medium" class="difficulty-btn bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-md transition-all duration-300">
            <i class="fa fa-meh-o mr-1"></i>中等
          </button>
          <button data-difficulty="hard" class="difficulty-btn bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-md transition-all duration-300">
            <i class="fa fa-frown-o mr-1"></i>困难
          </button>
        </div>

        <!-- 游戏控制 -->
        <div id="gameControls" class="mt-4 flex justify-center gap-4 hidden">
          <button id="startBtn" class="bg-primary hover:bg-primary/80 text-white px-4 py-2 rounded-md">
            <i class="fa fa-play mr-1"></i>开始游戏
          </button>
          <button id="pauseBtn" class="bg-secondary hover:bg-secondary/80 text-white px-4 py-2 rounded-md" disabled>
            <i class="fa fa-pause mr-1"></i>暂停
          </button>
          <button id="restartBtn" class="bg-accent hover:bg-accent/80 text-white px-4 py-2 rounded-md" disabled>
            <i class="fa fa-refresh mr-1"></i>重新开始
          </button>
        </div>
      </div>

      <!-- 游戏信息 -->
      <div class="lg:w-1/3 bg-dark-light rounded-md p-4">
        <div class="text-center mb-4">
          <h2 class="text-xl font-bold text-secondary">游戏信息</h2>
        </div>

        <div class="space-y-4">
          <div class="bg-dark rounded-md p-3">
            <div class="flex justify-between items-center">
              <span class="text-gray-400">当前分数</span>
              <span id="score" class="text-xl font-bold text-primary">0</span>
            </div>
          </div>

          <div class="bg-dark rounded-md p-3">
            <div class="flex justify-between items-center">
              <span class="text-gray-400">移动步数</span>
              <span id="moves" class="text-xl font-bold text-secondary">0</span>
            </div>
          </div>

          <div class="bg-dark rounded-md p-3">
            <div class="flex justify-between items-center">
              <span class="text-gray-400">游戏时间</span>
              <span id="time" class="text-xl font-bold text-accent">00:00</span>
            </div>
          </div>

          <div class="bg-dark rounded-md p-3">
            <h3 class="font-bold mb-2">当前难度</h3>
            <div id="currentDifficulty" class="text-accent text-center py-2 border border-accent/30 rounded">
              请选择难度
            </div>
          </div>

          <div class="bg-dark rounded-md p-3">
            <h3 class="font-bold mb-2">操作说明</h3>
            <ul class="text-sm text-gray-300 space-y-1">
              <li><i class="fa fa-arrow-up mr-1"></i>上移</li>
              <li><i class="fa fa-arrow-down mr-1"></i>下移</li>
              <li><i class="fa fa-arrow-left mr-1"></i>左移</li>
              <li><i class="fa fa-arrow-right mr-1"></i>右移</li>
              <li><i class="fa fa-space-shuttle mr-1"></i>空格键: 暂停/继续</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // 检查用户是否登录
    async function checkLogin() {
      try {
        const response = await fetch('http://127.0.0.1:5000/api/check_login', {
          credentials: 'include',
        });
        const data = await response.json();
        return data.message === '已登录';
      } catch (error) {
        console.error('检查登录状态失败:', error);
        return false;
      }
    }

    // 页面加载时检查登录状态
    checkLogin().then(isLoggedIn => {
      if (!isLoggedIn) {
        window.location.href = 'login.html';
      }
    });

    // 游戏逻辑实现
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreElement = document.getElementById('score');
      const movesElement = document.getElementById('moves');
      const timeElement = document.getElementById('time');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');
      const difficultyBtns = document.querySelectorAll('.difficulty-btn');
      const difficultySelection = document.getElementById('difficultySelection');
      const gameControls = document.getElementById('gameControls');
      const currentDifficultyElement = document.getElementById('currentDifficulty');

      // 设置画布尺寸
      canvas.width = 600;
      canvas.height = 600;

      // 预绘制网格以提高性能
      const gridCanvas = document.createElement('canvas');
      gridCanvas.width = canvas.width;
      gridCanvas.height = canvas.height;
      const gridCtx = gridCanvas.getContext('2d');

      // 难度配置 - 调整简单难度速度，使其更流畅
      const difficultySettings = {
        easy: {
          speed: 120, // 稍微提高速度（从150调整为120），减少卡顿感知
          wallFoodProbability: 0.2 // 20%概率食物出现在靠墙位置
        },
        medium: {
          speed: 100, // 移动间隔（毫秒）
          wallFoodProbability: 0.5 // 50%概率食物出现在靠墙位置
        },
        hard: {
          speed: 60, // 移动间隔（毫秒）
          wallFoodProbability: 0.8 // 80%概率食物出现在靠墙位置
        }
      };

      // 当前选择的难度
      let selectedDifficulty = null;
      let currentSpeed = 100; // 默认速度
      let currentWallFoodProbability = 0.5; // 默认靠墙概率

      // 游戏变量
      let snake = [{ x: 10, y: 10 }];
      let food = { x: 5, y: 5 };
      let direction = 'right';
      let nextDirection = 'right';
      let score = 0;
      let moves = 0;
      let gameTime = 0;
      let gameInterval;
      let isPaused = false;
      let gameStarted = false;
      let timerInterval;
      let isGameOver = false;
      let isRestarting = false;

      // 游戏网格大小
      const gridSize = 20;
      const gridWidth = canvas.width / gridSize;
      const gridHeight = canvas.height / gridSize;

      // 预绘制网格
      function preDrawGrid() {
        gridCtx.fillStyle = 'black';
        gridCtx.fillRect(0, 0, canvas.width, canvas.height);

        gridCtx.strokeStyle = '#333';
        gridCtx.lineWidth = 0.5; // 细线减少绘制负担

        // 横向网格线
        for (let y = 0; y <= canvas.height; y += gridSize) {
          gridCtx.beginPath();
          gridCtx.moveTo(0, y);
          gridCtx.lineTo(canvas.width, y);
          gridCtx.stroke();
        }

        // 纵向网格线
        for (let x = 0; x <= canvas.width; x += gridSize) {
          gridCtx.beginPath();
          gridCtx.moveTo(x, 0);
          gridCtx.lineTo(x, canvas.height);
          gridCtx.stroke();
        }
      }

      // 初始化游戏
      function initGame() {
        snake = [{ x: 10, y: 10 }];
        food = { x: 5, y: 5 };
        direction = 'right';
        nextDirection = 'right';
        score = 0;
        moves = 0;
        gameTime = 0;
        isPaused = false;
        isGameOver = false;

        updateDisplay();
        generateFood();
        draw();
      }

      // 选择难度
      function selectDifficulty() {
        if (gameStarted) return;

        const difficulty = this.getAttribute('data-difficulty');
        selectedDifficulty = difficulty;
        currentSpeed = difficultySettings[difficulty].speed;
        currentWallFoodProbability = difficultySettings[difficulty].wallFoodProbability;

        // 更新UI显示
        difficultyBtns.forEach(btn => {
          btn.classList.remove('ring-2', 'ring-white', 'scale-105');
        });
        this.classList.add('ring-2', 'ring-white', 'scale-105');

        // 显示当前难度
        const difficultyNames = {
          easy: '简单',
          medium: '中等',
          hard: '困难'
        };
        currentDifficultyElement.textContent = difficultyNames[difficulty];

        // 显示游戏控制按钮
        difficultySelection.classList.add('hidden');
        gameControls.classList.remove('hidden');
      }

      // 开始游戏
      function startGame() {
        if (gameStarted || !selectedDifficulty) return;

        gameStarted = true;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        restartBtn.disabled = false;
        isPaused = false;
        isGameOver = false;

        gameInterval = setInterval(gameLoop, currentSpeed);
        timerInterval = setInterval(() => {
          gameTime++;
          updateDisplay();
        }, 1000);
      }

      // 暂停游戏
      function pauseGame() {
        if (isRestarting) return;

        isPaused = !isPaused;

        if (isPaused) {
          // 暂停时清除定时器
          if (gameInterval) {
            clearInterval(gameInterval);
            gameInterval = null;
          }
          if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
          }
          pauseBtn.innerHTML = '<i class="fa fa-play mr-1"></i>继续';
        } else {
          // 恢复时重新创建定时器
          gameInterval = setInterval(gameLoop, currentSpeed);
          timerInterval = setInterval(() => {
            gameTime++;
            updateDisplay();
          }, 1000);
          pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';
        }
      }

      // 重新开始游戏
      function restartGame() {
        if (isRestarting) return;
        isRestarting = true;

        // 禁用按钮
        pauseBtn.disabled = true;
        restartBtn.disabled = true;

        // 清除定时器
        if (gameInterval) {
          clearInterval(gameInterval);
          gameInterval = null;
        }
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        // 显示确认对话框
        const confirmRestart = confirm(isGameOver
            ? '游戏已经结束，是否重新开始？'
            : '是否确认重新开始？');

        if (confirmRestart) {
          // 保存当前记录
          if (gameStarted) {
              saveGameRecord(
                  score,
                  moves,
                  `${Math.floor(gameTime / 60)
                      .toString()
                      .padStart(2, '0')}:${(gameTime % 60).toString().padStart(2, '0')}`
              );
          }

          // 重新初始化游戏
          initGame();
          draw();

          // 倒计时后启动游戏
          let count = 3;
          const countdownInterval = setInterval(() => {
              draw();

              // 绘制倒计时
              ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
              ctx.fillRect(0, 0, canvas.width, 80);
              ctx.fillStyle = '#FFD166';
              ctx.font = 'bold 48px Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(count > 0 ? `准备开始: ${count}` : '开始！', canvas.width / 2, 40);

              count--;

              if (count < -1) {
                  clearInterval(countdownInterval);
                  draw();

                  // 启动游戏
                  gameStarted = true;
                  isPaused = false;
                  isGameOver = false;
                  startBtn.disabled = true;
                  pauseBtn.disabled = false;
                  pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';

                  // 启动游戏循环
                  gameInterval = setInterval(gameLoop, currentSpeed);
                  timerInterval = setInterval(() => {
                      gameTime++;
                      updateDisplay();
                  }, 1000);

                  // 重置状态
                  isRestarting = false;
                  restartBtn.disabled = false;
                  pauseBtn.disabled = false;
              }
          }, 1000);
        } else {
          // 用户取消重新开始
          if (isGameOver) {
              startBtn.disabled = false;
          } else if (gameStarted) {
              isPaused = false;
              gameInterval = setInterval(gameLoop, currentSpeed);
              timerInterval = setInterval(() => {
                  gameTime++;
                  updateDisplay();
              }, 1000);
              pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';
          }

          // 重置状态
          isRestarting = false;
          restartBtn.disabled = false;
        }
      }

      // 游戏主循环
      function gameLoop() {
        if (isPaused || isGameOver) return;

        // 更新蛇的位置
        const head = { x: snake[0].x, y: snake[0].y };

        switch (direction) {
          case 'up':
            head.y--;
            break;
          case 'down':
            head.y++;
            break;
          case 'left':
            head.x--;
            break;
          case 'right':
            head.x++;
            break;
        }

        // 检查是否碰撞边界
        if (
          head.x < 0 ||
          head.x >= gridWidth ||
          head.y < 0 ||
          head.y >= gridHeight
        ) {
          gameOver();
          return;
        }

        // 检查是否碰撞自身
        for (let i = 0; i < snake.length; i++) {
          if (snake[i].x === head.x && snake[i].y === head.y) {
            gameOver();
            return;
          }
        }

        // 更新方向
        direction = nextDirection;
        moves++;

        // 将新头部添加到蛇身体
        snake.unshift(head);

        // 检查是否吃到食物
        if (head.x === food.x && head.y === food.y) {
          score += 10;
          generateFood();
        } else {
          // 如果没吃到食物，移除尾部
          snake.pop();
        }

        // 更新显示
        updateDisplay();
        draw();
      }

      // 生成食物 - 根据难度调整靠墙概率
      function generateFood() {
        let newFood;
        let isWallPosition;

        do {
          // 决定是否生成在靠墙位置
          const isWallFood = Math.random() < currentWallFoodProbability;

          if (isWallFood) {
            // 生成靠墙位置的食物
            const side = Math.floor(Math.random() * 4); // 0-3 代表四个方向
            switch (side) {
              case 0: // 上边
                newFood = {
                  x: Math.floor(Math.random() * gridWidth),
                  y: 0
                };
                break;
              case 1: // 右边
                newFood = {
                  x: gridWidth - 1,
                  y: Math.floor(Math.random() * gridHeight)
                };
                break;
              case 2: // 下边
                newFood = {
                  x: Math.floor(Math.random() * gridWidth),
                  y: gridHeight - 1
                };
                break;
              case 3: // 左边
                newFood = {
                  x: 0,
                  y: Math.floor(Math.random() * gridHeight)
                };
                break;
            }
          } else {
            // 生成非靠墙位置的食物（至少距离边界1格）
            newFood = {
              x: 1 + Math.floor(Math.random() * (gridWidth - 2)),
              y: 1 + Math.floor(Math.random() * (gridHeight - 2))
            };
          }

          // 检查是否与蛇身重叠
          isWallPosition = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
        } while (isWallPosition);

        food = newFood;
      }

      // 绘制游戏 - 优化版本，提高性能
      function draw() {
          // 绘制预渲染的网格（大幅提升性能）
          ctx.drawImage(gridCanvas, 0, 0);

          // 绘制蛇 - 简化绘制逻辑，减少计算量
          snake.forEach((segment, index) => {
              const x = segment.x * gridSize;
              const y = segment.y * gridSize;

              if (index === 0) {
                  // 蛇头 - 简化绘制，去掉渐变
                  ctx.fillStyle = '#FF3A3A';
                  ctx.fillRect(x, y, gridSize - 1, gridSize - 1);

                  // 简化眼睛绘制
                  ctx.fillStyle = 'white';
                  const eyeSize = gridSize / 6;
                  const eyeOffset = gridSize / 4;

                  if (direction === 'right') {
                      ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + eyeOffset, eyeSize, eyeSize);
                      ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                  } else if (direction === 'left') {
                      ctx.fillRect(x + eyeOffset, y + eyeOffset, eyeSize, eyeSize);
                      ctx.fillRect(x + eyeOffset, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                  } else if (direction === 'up') {
                      ctx.fillRect(x + eyeOffset, y + eyeOffset, eyeSize, eyeSize);
                      ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + eyeOffset, eyeSize, eyeSize);
                  } else if (direction === 'down') {
                      ctx.fillRect(x + eyeOffset, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                      ctx.fillRect(x + gridSize - eyeOffset - eyeSize, y + gridSize - eyeOffset - eyeSize, eyeSize, eyeSize);
                  }
              } else {
                  // 蛇身 - 简化绘制，去掉渐变和圆角
                  // 根据位置轻微调整颜色，减少计算量
                  const alpha = Math.max(0.5, 1 - (index / snake.length) * 0.5);
                  ctx.fillStyle = `rgba(0, 168, 255, ${alpha})`;
                  ctx.fillRect(x, y, gridSize - 1, gridSize - 1);
              }
          });

          // 绘制食物 - 简化绘制
          ctx.fillStyle = '#FFD166';
          const foodX = food.x * gridSize;
          const foodY = food.y * gridSize;
          ctx.beginPath();
          ctx.arc(
              foodX + gridSize / 2,
              foodY + gridSize / 2,
              (gridSize - 1) / 2,
              0,
              Math.PI * 2
          );
          ctx.fill();

          // 如果游戏暂停，显示暂停信息
          if (isPaused) {
              ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.fillStyle = 'white';
              ctx.font = '20px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('游戏暂停', canvas.width / 2, canvas.height / 2);
          }
      }

      // 更新显示信息
      function updateDisplay() {
        scoreElement.textContent = score;
        movesElement.textContent = moves;

        const minutes = Math.floor(gameTime / 60)
          .toString()
          .padStart(2, '0');
        const seconds = (gameTime % 60).toString().padStart(2, '0');
        timeElement.textContent = `${minutes}:${seconds}`;
      }

      // 游戏结束
      function gameOver() {
        clearInterval(gameInterval);
        clearInterval(timerInterval);

        isGameOver = true;
        gameStarted = false;

        // 先绘制最后游戏状态
        draw();

        // 顶部显示游戏结束信息
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, 100);

        ctx.fillStyle = 'white';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('游戏结束', canvas.width / 2, 30);
        ctx.font = '20px Arial';
        ctx.fillText(`最终得分: ${score}`, canvas.width / 2, 70);

        // 保存游戏记录
        saveGameRecord(
            score,
            moves,
            `${Math.floor(gameTime / 60)
                .toString()
                .padStart(2, '0')}:${(gameTime % 60).toString().padStart(2, '0')}`
        );

        // 重置按钮状态
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        restartBtn.disabled = false;
        pauseBtn.innerHTML = '<i class="fa fa-pause mr-1"></i>暂停';
      }

      // 保存游戏记录
      async function saveGameRecord(score, moves, time) {
        try {
          const response = await fetch('/api/game', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({
              score,
              moves,
              time,
              difficulty: selectedDifficulty
            }),
          });

          const data = await response.json();
          console.log(data.message);
        } catch (error) {
          console.error('Error saving game record:', error);
        }
      }

      // 键盘控制
      document.addEventListener('keydown', e => {
        if (!gameStarted) return;

        if (e.key === ' ') {
          pauseGame();
          return;
        }

        if (isPaused) return;

        switch (e.key) {
          case 'ArrowUp':
            if (direction !== 'down') nextDirection = 'up';
            break;
          case 'ArrowDown':
            if (direction !== 'up') nextDirection = 'down';
            break;
          case 'ArrowLeft':
            if (direction !== 'right') nextDirection = 'left';
            break;
          case 'ArrowRight':
            if (direction !== 'left') nextDirection = 'right';
            break;
        }
      });

      // 主页按钮点击事件
      document.getElementById('homeBtn').addEventListener('click', e => {
        e.preventDefault();
        if (gameStarted) {
          clearInterval(gameInterval);
          clearInterval(timerInterval);
          saveGameRecord(
            score,
            moves,
            `${Math.floor(gameTime / 60)
              .toString()
              .padStart(2, '0')}:${(gameTime % 60).toString().padStart(2, '0')}`
          ).then(() => {
            window.location.href = 'index.html';
          });
        } else {
          window.location.href = 'index.html';
        }
      });

      // 初始化预绘制网格
      preDrawGrid();

      // 难度选择按钮事件
      difficultyBtns.forEach(btn => {
        btn.addEventListener('click', selectDifficulty);
      });

      // 按钮事件绑定
      startBtn.addEventListener('click', startGame);
      pauseBtn.addEventListener('click', pauseGame);
      restartBtn.addEventListener('click', restartGame);

      // 初始化游戏
      initGame();
    });
  </script>
</body>
</html>